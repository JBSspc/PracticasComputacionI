# -*- coding: utf-8 -*-
"""Calculadora.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vcy1vEKEMIvdyA7ZlG1O9cVu03ggR5Uv
"""
# Importamos las librerías que requiere el programa
import math # para log en el calculo de pH
import numpy as np # para los arreglos de G-J en el balanceo de ecuaciones químicas
import sys # para GJ, cuando se divida entre 0
print("Bienvenido a la Calculadora de Bioquímica")
def switch(): # para el menú de opciones
  print("Escoja una opción: \n 1 : Calcular pH \n 2 : Especie dominate \n 3 : Calcular punto Isoeléctrico \n 4 : Calcular carga neta a cierto pH \n 5 : Balanceo de ecuaciones")

  option = int(input("Introduzca la opción: ")) # el ususario escge una opción

# Calcular pH
  def pH(): 
    num1 = float(input("Molaridad de la sustancia agregada: "))
    num2 = float(input("Volumen de la sustancia agregada (L): "))
    num3 = float(input("Volumen del agua (L): "))
    result = (math.log10((num1 * num2)/(num2 + num3)))*(-1)
    print("pH de la solución: ", result)

# Conocer la especie dominante (usamos ecuación de Henderson-Hassellback)
  def DominantSus():
    num1 = float(input("pka: "))
    num2 = float(input("pH: "))
    result = (-(-num1)) - (-(-num2))
    if result == 0:
      print("Ambas especies están en equilibrio")
    else:
      if result < 0:
        print("Predomina la especie: DESPROTONADA")
      else:
        print("Predomina la especie: PROTONADA")

# Calcular punto isoeléctrico
  def pI():
    num1 = float(input("pH1: "))
    num2 = float(input("pH2: "))
    result = (num1 + num2) / 2 # es el promedio de los 2 ph entre los que se encuentra la molécula a carga neutra
    print("Punto Isoeléctrico: ", result)

# Calcular la carga de una molécula a cierto pH
  def carga():
    NombreMol = str(input('\nNombre de la molécula: ')) # nombre de la molécula 
    MolPh = float(input('pH de la solución (buffer): ')) # pH de la solución
    n = int(input('Numero de grupos: ')) # número de grupos que conforman la molécula
    if n == 3: # vamos a dejarlo en 3 grupos (repetirmeos lo mismo para cada grupo)
        G1 = str(input('\nGrupo 1: ')) # nombre del grupo 1 (string)
        pk1 = float(input('pk del grupo ' + G1 + ' : ' )) #pka del grupo (float)
        C1 = int(input('carga del grupo ' + G1 +' a pH mayor a ' + str(pk1) +' : ')) # carga a pH > pka (int), escribimos 'pk1' como str para evitar conflictos
        # De la ecuación de Henderson-Hassellback hacemos nacen las siguientes alternativas
        if MolPh < pk1:
          C1 += 1
        else:
          C1 = C1
        G2 = str(input('\nGrupo 2: ')) # nombre del grupo 2 (string)
        pk2 = float(input('pk del grupo ' + G2 +  ' : ' )) #pka del grupo (float)
        C2 = int(input('carga del grupo ' + G2 +' a pH mayor a ' + str(pk2) +' : ')) # carga a pH > pka (int), escribimos 'pk2' como str para evitar conflictos
        # De la ecuación de Henderson-Hassellback hacemos nacen las siguientes alternativas
        if MolPh < pk2:
          C2 += 1
        else:
          C2 = C2   
        G3 = str(input('\nGrupo 3: ')) # nombre del grupo 3 (string)
        pk3 = float(input('pk del grupo ' + G3 +  ' : ' )) #pka del grupo (float)
        C3 = int(input('carga del grupo ' + G3 +' a pH mayor a ' + str(pk3) +' : ')) # carga a pH > pka (int), escribimos 'pk3' como str para evitar conflictos
        # De la ecuación de Henderson-Hassellback hacemos nacen las siguientes alternativas
        if MolPh < pk3:
          C3 += 1
        else:
          C3 = C3
    MolCharge = C1 + C2 + C3 # la carga de la molécula es la suma de las cargas de sus grupos

    print('\nCarga de la molécula a pH = ' + str(MolPh) + ' es: ', MolCharge)
  
# Blanceo de reacciones químicas por método matemático  
  def balanceo(): # Se puede resolver por Gauss-Jordan, implementamos el método
    v = int(input("Número de ecuaciones: ")) # input del usuario
    z = np.zeros((v, v + 1)) # matriz de 0
    x = np.zeros((v, 1)) # matriz de 0 para la solución
    print('\nCoeficientes de la matriz aumentada: ') # input coef. matriz aumentada
    for i in range(v):
      for j in range(v + 1):
        z[i][j] = float (input('Valor elemento [' + str(i) + '][' + str(j) + ']: '))
    
    # Gauss-Jordan
    for i in range(v):
      if z[i][j] == 0.0:
        sys.exit('Alto! Divides entre 0!')
      for j in range(v):
        if j in range(v):
          if i != j:
            r = z[j][i] / z[i][i]
            for k in range(v + 1):
              z[j][k] = z[j][k] - r * z[i][k]
    
    # Para la solución
    for i in range(v):
      x[i] = z[i][v] / z[i][i]

    # Mostrar la solución en consola
    print('\nSolucion: ')
    for i in range(v):
      print('X%d = %0.2f' %(i, x[i]), end = '\t')  

# Diccionatio de opciones
  dict = {
      1 : pH,
      2 : DominantSus,
      3 : pI,
      4 : carga,
      5 : balanceo
  }
  dict.get(option)() # Esocger una opción del diccionario

switch()

NombreMol = str(input('\nNombre de la molécula: '))
MolPh = float(input('pH de la solución (buffer): '))
n = int(input('Numero de grupos: '))
if n == 3:
    G1 = str(input('\nGrupo 1: '))
    pk1 = float(input('pk del grupo ' + G1 + ' : ' ))
    C1 = int(input('carga del grupo ' + G1 +' a pH mayor a ' + str(pk1) +' : '))
    if MolPh < pk1:
      C1 += 1
    else:
      C1 = C1
    G2 = str(input('\nGrupo 2: '))
    pk2 = float(input('pk del grupo ' + G2 +  ' : ' ))
    C2 = int(input('carga del grupo ' + G2 +' a pH mayor a ' + str(pk2) +' : '))
    if MolPh < pk2:
      C2 += 1
    else:
      C2 = C2   
    G3 = str(input('\nGrupo 3: '))
    pk3 = float(input('pk del grupo ' + G3 +  ' : ' ))
    C3 = int(input('carga del grupo ' + G3 +' a pH mayor a ' + str(pk3) +' : '))
    if MolPh < pk3:
      C3 += 1
    else:
      C3 = C3
MolCharge = C1 + C2 + C3

print('\nCarga de la molécula a pH = ' + str(MolPh) + ' es: ', MolCharge)
