# Unidad IV
## Apuntadores
<div align="justify"><p>Hasta ahora se ha abordado el paso de parámetros por valor y por referencia <code>&</code> Los apuntadores pueden utilizarse para almacenar direcciones de memoria físicas. (pueden ser de utilidad para generar estrcuturas de datos dinámicas, pilas, colas, árboles, etc.). Ejemplos:</p></div>

* Sorting
* Link list
* List
* Spanning tree
* Tree. Permiten interconectar varios nodos. Cada nodo padre tiene dos hijos (árbol binario).
* Graph. Los grafos nos permiten representar interacciones entre redes.
* Stack. 
  * Pilas: Sólo pueden sacar el elemento de "en cima"; "el último en entrar, es el primero en salir".
  * Colas: Contrario a las pilas: "El primero en entrar es el primero en salir.
* Hashing. Mapear un elemento a una posición de forma automática.

<div align="justify">Los apuntadores son un tipo especial de variables que pueden almacenar direcciones de memoria. Por lo general una variable contiene un valor específicp. Un apuntador contiene la <strong>dirección</strong> de una variable, que a su vez contiene un valor específico.</div>

### Declaración de inicialización
```cpp
int *cuentaPtr, cuenta;
double *xPtr, *yPtr;
int y = 5; // decalara la variable y
int *yPtr = nullptr; // declara la variable apuntador yPtr; nullptr -> vacío (buena práctica)
```

#### Operador amperson &
El operador <code>&</code> es un operador unario que obtiene la dirección de memoria de su operando. Ejemplo:
```cpp
yPtr = &y; // asigna la dirección y a yPtr
```
Asinga la dirección de la variable y al apuntador yPtr. Se dice que la variable yPtr "apunta a" y.

#### Operadore de indirección

El operador <code>*</code> unario, se conoce como operador de indirección o de desreferencia. Devuelve el valor que representa el objeto al que apunta su operando apuntador. Ejmplo:
```cpp
cout << *yPtr <<endl;
*yPtr = 9;

```

#### Paso por referencia a través de apuntadores

Vamos como sería sin apuntadores
```cpp
#include <iostream>
using namespace std;

int cuadradoPorValor(int); //prototipo
int main()
{
    int numero = 5;
    cout << "El valor original del numero es " <<numero;
    numero = cuboPorValor(numero); //pasa el numero por valor a cuadradoPorValor
    cout << "\nEl nuevo valor del numero es " <<numero <<enld;
} // fin de main

//caclula y devuelve el cubo del argumento entero
int cuadradoPorValor(int n)
{
    return n * n; // eleva al cubo la variable local n y devuelve el resultado
} // fin de la función cuadradoPorValor
```
Ahora, con apuntadores:
```cpp
#include<iostream>
using namespace std;

void cuadradoPorReferencia (int *); // prototipo
int main ()
{
    int numero = 5;
    cout << "El valor original del numero es " <<numero;
    cuadradoPorReferencia(&numero); //pasa la dirección de numero a cuadradoPorReferencia
    cout << "\nEl nuevo Valor del numero es " <<numero <<endl;
} //fin de main

//calcula
```
